Database ActiveRow
****************

Every row returned by [Selection | api:Nette\Database\Table\Selection] is represented by [ActiveRow | api:Nette\Database\Table\ActiveRow] instance. This class provides standard interface for accessing fetched columns. You can read data as properties or by array access. Array access provides also possibility to get column by its index.

/--code php
echo $book->id;
echo $book['title'];
echo $book[0];         // the first fetched column
\--

If column does not exist, it's thrown [MemberAccessException | api:Nette\MemberAccessException]. You can check if column is set by standard isset construct.
/--code php
isset($book->id);
isset($book['title']);
\--
Be careful, `isset` will return FALSE even if the column was fetched, but the value is NULL.

Relations
=======

The main Nette\Database\Table principle is to fetch data from different tables separately. This behavior is maintained by Nette\Database itself, row's related data will be fetched for all other rows at once. We have two simple types of relation: "has one" and "has many".

.[note]
We will use DiscoveredReflection, which fetches relationships right from your database.

Has one relation
---------------
Has one relation is often use-case. Book *has one* author. Book *has one* translator. Getting related row is mainly done by [ref() | api:Nette\Database\Table\ActiveRow::ref()] method. Ref() method accepts two arguments: target table name and source joining column. See example:

/--code php
$book = $selectionFactory->table('book')->get(1);
$book->ref('author', 'author_id');
\--

In example above we fetch related author entry from `author` table, the author primary key is searched by `book.author_id` column. Ref() method returns ActiveRow instance or NULL if there is no appropriate entry. Returned row is ActiveRow instance so we can work with it as with current book entry.

/--code php
$author = $book->ref('author', 'author_id');
$author->name;
$author->born;

// or directly
$book->ref('author', 'author_id')->name;
$book->ref('author', 'author_id')->born;
\--

Book has also one translator, so getting translator name is quite easy.
/--code php
$book->ref('author', 'translator_id')->name
\--

It's everything fine, but it's quite ugly, don't you think? Database has already defined foreign keys so why not use them automatically. Yes, we can!

If we call property, which does not exist, ActiveRow tries to resolve the calling property name as "has one" relation. Getting this property is the same as calling ref() method just with one argument. We will call the only argument as the **key**. Key will be resolved to particular foreign key relation. The called key is matched against row columns, if matches, the matched column foreign key is used for getting data from related target table. See example:

/--code php
$book->author->name;
// same as
$book->ref('author')->name;
\--

ActiveRow instance has no author column. All book columns are searched for match with *key*. Matching means the column have to contains the key. So example above match `author_id` column, it contains "author" key. If you want to get book translator, just use "translator" as a key, "translator" key will match `translator_id` column. You can find more about key matching logic in [Joining expressions | database-joining-expressions] chapter.

/--code php
echo $book->title . ": ";
echo $book->author->name;
if ($book->translator) {
	echo " (translated by " . $book->translator->name . ")";
}
\--

If you have fetched more than one book you should use the same approach. Nette\Database will fetch authors and translators for all fetched books at once.

/--code php
$books = $selectionFactory->table('book');
foreach ($books as $book) {
	echo $book->title . ": ";
	echo $book->author->name;
	if ($book->translator) {
		echo " (translated by " . $book->translator->name . ")";
	}
}
\--

The code will run only these 3 queries:
/--code sql
SELECT * FROM `book`;
SELECT * FROM `author` WHERE (`id` IN (1, 2, 3)); -- ids of fetched books from author_id column
SELECT * FROM `author` WHERE (`id` IN (2, 3));    -- ids of fetched books from translator_id column
\--


Has many relation
-----------------

"Has many" relation is just reversed "has one" relation. Author *has* written *many* books. Author *has* translated *many* books. As you can see, this type of relation is a little bit more difficult, because the relation is "named" ("written", "translated"). ActiveRow instance has [related() | api:Nette\Database\Table\ActiveRow::related()] method, which will return array of related entries. Entries are also ActiveRow instances. See example bellow:

/--code php
$author = $selectionFactory->table('author')->get(11);
echo $author->name . " has written:";

foreach ($author->related('book.author_id') as $book) {
	echo $book->title;
}

echo "and translated:";
foreach ($author->related('book.translator_id') as $book) {
	echo $book->title;
}
\--

[Related() | api:Nette\Database\Table\ActiveRow::related()] method accepts full join description passed as two arguments or as one argument joined by dot. The first argument is the target table, the second is the target column.
/--code php
$author->related('book.translator_id');
// same as
$author->related('book', 'translator_id');
\--

You can use Nette\Database heuristic based on foreign keys and provide only **key** argument. Key will be matched against all foreign keys directing into the current table (`author` table). If there will be any match, Nette\Database will use this foreign key, otherwise will throw appropriate exception: [MissingReferenceException | api:Nette\Database\Reflection\MissingReferenceException] or [AmbiguousReferenceKeyException | api:Nette\Database\Reflection\AmbiguousReferenceKeyException]. You can find more about key matching logic in [Joining expressions | database-joining-expressions] chapter.

Of course you can call related methods for all fetched authors, Nette\Database will fetch appropriate books again only at once.

/--code php
$authors = $selectionFactory->table('author');
foreach ($authors as $author) {
	echo $author->name . " has written:";
	foreach ($author->related('book') as $book) {
		$book->title;
	}
}
\--

Example above will run only two queries:
/--code sql
SELECT * FROM `author`;
SELECT * FROM `book` WHERE (`author_id` IN (1, 2, 3)); -- ids of fetched authors
\--

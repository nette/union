Komponenty
***********

IN DEVELOPMENT .[caution]


Webová stránka se obvykle skládá z několika menších součástí, například to může být anketa, menší boxy aj. To se dá vyřešit pomocí „komponent“ tzn. třídy, která dědí od [Nette\Application\Control | api:]Control.

Komponenta [Nette\Application\Control | api:] ač má mnoho společných rysů s [Nette\Application\Presenter | api:] nemá svůj životní cyklus v pravém slova smyslu. Jen metody [Nette\Component::attached()] a [Nette\Component::detached()] umožňují detekovat, zda byl Control připojen k nebo odpojen od rodiče((viz dále)).

Každá komponenta děděná z třídy Control má jako první parametr konstruktoru rodiče((viz dále)) v hierarchii stromu komponent. Rodičem může být [Presenter | doc:cs:Aplikace/Presentery], nějaká *komponenta* nebo jakýkoliv jiný objekt implementující rozhraní [Nette\IComponentContainer | api:]. Toto nám umožnuje vytvářet dynamický strom komponent.

Komponenta (tedy přesněji vykreslitelná komponenta [Control | api:Nette\Application\Control]) nepředstavuje pravoúhlou oblast ve stránce, ale logickou komponentu, která se může renderovat i do více podob. Každá komponenta může být navíc na stránce vykreslena vícekrát, podmíněně, nebo pokaždé s jinou šablonou atd.


Nevykreslitelná komponenta
==========================
Jedná se například o [Nette\Application\AppForm | api:], tedy formulář. O jeho vykreslení se stará [Nette\Forms\ConventionalRenderer|api:], proto je to nevykreslitelná komponenta. To nám umožňuje změnit styl vykreslování daného formuláře aniž bychom měnili jeho vlastní logiku.


Vykreslitelná komponenta
========================
Jedná se o komponentu, která obsahuje šablonu. Tedy zobrazuje informace a reaguje na požadavky uživatele.

Jednoduchý dialog jakokomponenta:
/--php
class DialogControl extends Nette\Application\Control
{
	/** @var bool Bude nám uchovávat stav rozhodnutí */
	private $decision = FALSE;

	/**
	 * Vykreslení komponenty
	 */
	public function render()
	{
		$template = parent::createTemplate(); //Vytvoříme šablonu
		$template->setFile(__DIR__ . '/DialogControl.phtml'); //Soubor se šablonou
		//Abychom měli decision pŕístupné i v šabloně
		$template->decision = $this->decision;

		$template->render();
	}

	/**
	 * Interakce uživatele
	 * @param bool $decision
	 */
	public function handleDecide($decision)
	{
		//Akceptujeme jen true nebo false
		if ($decision != 'true' && $decision != 'false') {
			throw new InvalidArgumentException;
		}
		//Nastav novou hodnotu decision
		$this->decision = $decision;
	}
}
\--

Šablona této komponenty:
/--html
<a href="{link decide!,'true'}">Ano</a> / <a href="{link decide!,'false'}">Ne</a>

{if $decision == 'true'} Ano {else} Ne {/if}
\--

Kontejner komponent
===================
TODO .[caution]

Továrnička
==========
Pro přiřazení komponent do "stromu komponent"((viz víše)) provádíme pomocí tzv. **Továrničky** jedná se o `protected` metody začínající na `createComponent` v rodiči((viz víše)) naší komponenty. Tyto metody nám zajistí *instancování* komponenty až ve chvíly kdy ji opravdu potřebujeme ([více zde | #Získání komponenty].

Ukázka jednoduché továrničky:
/--php
protected function createComponentMyDialog($name)
{
	//Použijeme víše uvedenou komponentu
	$control = new DialogControl($this, $name);
}
\--
Nepovinný parametr `$name` obsahuje vždy camelCase((myDialog)) název componenty, který je odpovídá PascalCase((MyDialog)) části za `createComponent`. Další řádek vytváří instanci danné((v našem případě se jedná o ukázkovou komponentu, která je ukázána víše)) komponenty, která je rovnou spárována s rodičem((viz víše)) a je jí automaticky nastaveno jméno.

Můžeme použít i jednodušší továrničku:
/--php
protected function createComponentMyDialog($name)
{
	//Použijeme víše uvedenou komponentu
	$control = new DialogControl;
	return $control;
}
\--
Zde nedochází okamžitému spárování komponenty s rodičem. V tomto případě dochází ke spárování až při vrácení komponenty rodiči. (`return $control;`)

Best practice Továrnička
------------------------
Jako **BestPractice** lze označit řešení 100% jistoty (skloubení obou možností dohromady):
/--php
protected function createComponentMyDialog($name)
{
	//Použijeme víše uvedenou komponentu
	$control = new DialogControl($this, $name);
	return $control;
}
\--

Vytvářet instanci komponenty můžeme i takto:
/--php
$control = new DialogControl;
$parent->addComponent($control, 'dialog');
\--
Nicméně tento způsob nedoporučujeme.

Získání komponenty
==================
Komponentu v rodiči získáme zavoláním metody [getComponent($name) | api:Nette\Application\ComponentContainer::getComponent()]. Kde parametr `$name` obsahuje název komponenty.
/--php
$this->getComponent('myDialog');
//nebo
$this['myDialog'];
\--
Pokud v době volání není komponenta *myDialog* instancována a/nebo spárována volá se automaticky její [továrnička | #Továrnička]


Použití v šabloně (s využítím [Latte Filteru | doc:cs:Šablony/Latte Filter]):
/--html latte
{control myDialog}
\--
odpovídá PHP kódu:
/--php
$control->getWidget('myDialog')->render();
\--
Více viz [Latte Filtr | doc:cs:Šablony/Latte Filter#control] .[see]

Pozor na case-sensitive název metody [továrničky | #Továrnička]. V názvu metody `createComponentMyDialog` je použit PascalCase((MyDialog)) ale samotný název instance komponenty je camelCase((myDialog)) .[caution]

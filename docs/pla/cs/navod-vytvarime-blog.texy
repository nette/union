Blog
****

Požadavky
--------

- Pochopení základních principů Nette (vztahy v MVP vzoru, základní představa o funci presenteru a jeho vztahu k šablonám)
- Povrchní znalost [dibi | http://dibiphp.com]
- [Prostředí pro běh Nette | www:pozadavky-frameworku]

Úvod
====
	Tvorba jednoduchého blogu je evergreenem mezi tématy tutoriálů různých webových frameworků. Bohužel, většina tutoriálů je okleštěna na minimální kostru úkolu a jako hlavní cíl si kladou ukát uživateli, jak jednoduše to s daným frameworkem jde. Tím se náročnost úlohy snižuje na úroveň, na které téměř nestojí za to nějaký framework používat. Neberte tedy tento tutoriál jako lákaldo na Nette, ale jako výukový materiál.
	V tutoriálu je použita namespacová verze Nette. Přestože aplikace je tak malá, že namespaces jsou tu spíš na obtíž, je to něco, co by každý potencionální uživatel Nette měl znát a umět používat. Pokud z technických důvodů nemůžete použít verzi pro PHP >5.3, stačí smazat ze zdrojových kódu všechny definice namespaces.

Blog za 19 minut!
-----------------
	Pomocí [RoR | http://rubyonrails.org] nebo [CodeIgniteru | http://codeigniter.com/] lze vytvořit „kompletní“ „blog“ za „20“ minut. Vážení, to nic není! Předvedu Vám, že s Nette to za 19 minut dokážete i Vy!

Instalace
=========
	Použijeme skeleton z  ditribuce. Nakopírujte ho do požadované složky serveru. Do složky `/libs/` nakopírujeme dibi (v distribuci Nette se nachází ve složce 3rdParty). Budeme také potřebovat databázi, já se budu držet MySQL, ale pokud chcete použít SQLite nebo PostgreSQL, není to problém (viz [#Databáze a model]).

Nezapomeňte, že ve skeletonu chybí Nette ve složce `/libs/`! .[note]


Databáze a model
===============
Začněmě s tvorbou příslušných tabulek. Jejich struktura je jasná ze zadání. Spustíme tedy na naši databázi příkazy:
/--code sql
CREATE TABLE `posts` (
`id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY ,
`title` VARCHAR( 128 ) NOT NULL ,
`body` TEXT NOT NULL ,
`date` DATETIME NOT NULL
) ENGINE = MYISAM CHARACTER SET utf8 COLLATE utf8_bin;
\--

Pro tabulku s příspěvky a

/--code sql
CREATE TABLE `comments` (
`id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY ,
`post_id` INT NOT NULL ,
`author` VARCHAR( 128 ) NOT NULL ,
`body` TEXT NOT NULL ,
`date` DATETIME NOT NULL
) ENGINE = MYISAM CHARACTER SET utf8 COLLATE utf8_bin;
\--

což bude (překvapivě) tabulka komentářů.

Pokud používáte jinou databázi, vytvořte stejnou strukturu tabulek. Dibi se postará o kompatibilitu na straně aplikace samo. .[note]

Když máme databázi, je potřeba se k ní s dibi připojit. Konfigurační soubory v Nette nabízejí elegantní způsob zprávy dat jako jsou údaje o databázi. Otevřete si `config.ini` ve složce `/app/` a do části `[common]` přidejte příslušnou modifikaci těchto řádků:

/--code ini
db.server = localhost
db.database = blogtut
db.username = blogtut
db.password = blogtut
db.driver = mysql
db.charset = utf8
db.lazy = TRUE
\--
A nyní připojení samotné. Do souboru `bootsrap.php` (zaváděcí soubor celé aplikace, jak už byste měli vědět) přídejte před řádek
/--code php
$application->run();
\--
toto:
/--code php
dibi::connect(Environment::getConfig('db'));
\--

Zde se na chvíli zastavíme a dáme si minutku teorie, ve které prohloubíme znalosti a odpovíme na možné otázky. Několik zásadních bodů:
- Nette [načítá soubory s kódem (ať už knihovny nebo části aplikace samotné) samo a dle potřeby | doc:nette-loaders]. Proto není žádný include či require ani tady, ani nikde jinde v našem kódu.
- Voláním `Environment::getConfig('db')` jsme z konfiguračního souboru získali pole určující nastavení databáze. Náš zápis je jiná reprezentace asociativního pole
/--code php
$db = array(
	'server' => 'localhost'
	'database' => 'blogtut'
	'username' => 'blogtut'
	'password' => 'blogtut'
	'driver'' => 'mysql'
	'charset => 'utf8'
	'lazy' => TRUE
	);
\--
- I když spojení s databází nastavujeme pokaždé, když se aplikace spustí, skutečné spojení probíhá jen tehdy, kdy je to skutečně potřeba, a to díky nastavení `db.lazy = TRUE` v `config.ini`.

Musíme ještě vytvořit modely pro obě tabulky.

/--code php
<?php

class PostsModel {

    static function fetchAll() {
        return dibi::query('
            SELECT *
            FROM [posts]
            ORDER BY [date]',dibi::DESC
            );
    }

}
\--

/--code php
<?php

class CommentsModel  {

    static function fetchAll($post_id) {
        return dibi::query('
            SELECT *
            FROM [comments]
            WHERE [post_id] = %s',$post_id);
    }

}
\--

Pro srozumitelnost budou prozatím jejich metody bez zbytečných ohledů tahat všechna dostupná data. Oba soubory s definicí tříd uložte do složky `/app/models/` a pojmenujte je podle třídy, kterou obsahují (`PostsModel.php`,`CommentsModel.php`).

Pokud jste zvyklí ukončovat skripty značkou `?>`, tak si rychle odvykněte! Ukončovací tagy jsou nepovinné a způsobují pouze problémy s whitespaces. .[caution]

Presenter
=========
	V `/app/presenters/` je HomepagePresenter. Ten poslouží jako dobrý základ našeho snažení. Přidáme do něj metodu, která vezme data z modelu a předá je do template k vykreslení.
	Metodu renderDefault upravíme na
/--code php
public function renderDefault() {
        $this->template->posts = PostsModel::fetchAll();
    }
\---

	Pokud si nejste jistí, proč pracuji s metodou default v presenteru Homepage, podívejter se na [routy | doc:nette-application-route] v souboru bootstrap.php. .[tip]

View
=====
	Výborně, teď máme v view `default` dostupnou proměnnou `$posts`, která obsahuje všechny příspěvky. Pojďme je vypsat.
	Ve složce `/app/templates/` je soubor `@layout.phtml`. Ten obsahuje základní rámec všech stránek, které budeme tvořit. Proto doporučuji si ho prohlédnout.
	V `/app/templates/Homepage/` je soubor `default.phtml`, který obsahuje definici bloku `content`, jehož obsah nahradí `{include #content}` v layoutu. Výpis všech článků může vypadat třeba takhle:
/--code html
{block content}
<h1>Můj blogísek</h1>
<div id="posts">
    {foreach $posts as $post}
    <div class="post">
        <h3>{$post['title']}</h3>
        <small>Přidáno {$post['date']|date}</small>
        <p>{$post['body']}</p>
    </div>
    {/foreach}
</div>
\--

Stáhněte si testovací data a zkuste otevřít root webu ve vašem prohlížeči. Výsledek by měl vypadat takto:


Dovolím si zkazit radost povinnou trochou teorie:
- Použité příkazy ve složených závorkách se nazývají makra [Latte filtru | doc:/sablony/latte-filter] a víc se o nich dozvíte v dokumentaci.
- Všiměte si části `{$post['date']|date}`. Ono date za vertical barem (svislítkem, chcete-li) je [helper | doc:/sablony/helpers]. Helper je jednoduchá funkce, která provádí s dannou proměnnou nějakou operaci podstatnou pouze pro zobrazení.

Komentáře
=========
	To ani nebolelo a zabralo to jen pár minut, ale blog je o komunikaci s lidmi. Proto potřebujeme přidat možnost komentovat příspěvky. Klasiciký přístup je takový, že na titulní straně se zobrazuje jen začátek textu s odkazem na celý text, kde je i možnost komentovat. Pojďme tedy na to.
Nová metoda presenteru
Protože zobrazení samostatného příspěvku nijak nesouvisí s titulní stranou, přidáme do našeho preseneru novou metodu:
/--code php
public function renderSingle($id) {
        $this->template->post = PostsModel::fetchSingle($id);
    }
\--

A vytvoříme příslušnou metodu v PostsModel:

/--code php
    static function fetchSingle($id) {
        return dibi::fetch('
            SELECT *
            FROM [posts]
            WHERE [id] = %i',$id
            );
    }
\--

Měli byste znát rozdíl mezi `dibi::query` a `dibi::fetch`. První vrací instanci třídy [DibiResult | http://api.dibiphp.com/1.3/DibiResult.html], kterou lze iterovat a tím získávat jednotlivé [DibiRow | http://api.dibiphp.com/1.3/DibiRow.html,] které implementují [ArrayAccess | http://php.net/manual/kr/class.arrayaccess.php], druhá vrací přímo `DibiRow`. .[note]

	Samozřejmě není optimální pro každý typ požadavku psát samostatnou funkci v modelu, máme na to různé fígly, ale prozatím KISS .(Keep it simple, stupid!).

	Také musíme vytvořit template pro tento požadavek, takže do `/app/templates/Homepage/single.phtml` vložíme:
/--code html
{block content}
<div class="post">
<h1>{$post['title']}</h1>
        <small>Přidáno {$post['date']|date}</small>
        <p>{$post['body']}</p>
</div>
\--
Nyní můžete v prohlížeči zkusit otevřit třeba `/Homepage/single/2`.

Opět se vracíme k routám. Podívejte se ještě jednou do `bootstrap.php`. .[tip]

Odkazy
------
Aby se sem dostal i běžný uživatel, potřebujeme nějaké odkazy z hlavní stránky. K tomu slouží makro [{plink …} | http://doc.nette.org/cs/generovani-odkazu]. Předělejme tedy view titulní stránky:

/--code html
{block content}
<h1>Můj blogísek</h1>
<div id="posts">
    {foreach $posts as $post}
    <div class="post">
        <h3>{$post['title']}</h3>
        <small>Přidáno {$post['date']|date}</small>
        <p>{$post['body']|truncate:300}</p>
        <a href="{plink single $post['id']}">Více...</a>
    </div>
    {/foreach}
</div>
\--

V naší pravidelné minutovce teorie bych nyní rád vyzdvihl dvě věci:
- Všimněte si helperu `truncate:300` a jeho efektu.
- Zápis `{plink single $post['id']}` znamená: vytvoř odkaz na akci single aktuálního presenteru a přidej parametr `$post['id']`. Je ekvivalentní se zápisem `{plink Homepage:single $post['id']}`. Je důležité, že nezapisujeme žádné URL, ale odkaz na akci presenteru.
- URL je zpětně vytvořeno tak, aby odpovídalo routám v bootstrap.php a Nette je na jeho tvaru naprosto nezávislé.

Formulář
--------
Konečně se dostáváme k něčemu „záživnějšímu“ - pojďmě si vytvořit formulář na odesílání komentářů! Nette má několik způsobů jak řešit formuláře, od tvrdého nakódování do templatu a odděleného zpracování vstupů po sofistikované metody jako [AppForm | doc:nette-application-appform].
Třída `AppForm` nabízí výhody, o kterým se mnohým ani nesnilo. Náš formulář bude samostatnou komponentou. Pokud jde o tvorbu komponent, používá „továrničky“, které vyrobí komponentu až v momentě, kdy je to skutečně potřeba.
Do `HomepagePresenter` přidáme klauzuli `use` a dvě funkce:
/--code php
use
    Nette\Application\AppForm,
        Nette\Forms\Form;
\--
/--code php
public function commentFormSubmitted(AppForm $form) {
        $data = $form->getValues();
        $data['date'] = new DateTime();
        CommentsModel::insert($data);
        $this->redirect('this');
    }

    public function createComponentCommentForm() {
        $f = new AppForm;
        $f->addText('author','Jméno')
                ->addRule(Form::FILLED,'To se neumíš ani podepsat?!');
        $f->addTextArea('body','Komentář')
                ->addRule(Form::FILLED,'Komentář je povinný!');
        $f->addSubmit('send','Odeslat');
        $f->addHidden('post_id',$this->request->params['id']);
        $f->onSubmit[] = array($this, 'commentFormSubmitted');
        return $f;
    }
\--
První z nich zpracovává odeslaný formulář (všimněte si přesměrování, které zajistí obnovení stránky), druhá je zmíněná továrnička.
Poslední věc, která zbývá, je úprava šablony:
/--code html
{block content}
<a href="{plink default}"><< home </a>
<div class="post">
<h1>{$post['title']}</h1>
        <small>Přidáno {$post['date']|date}</small>
        <p>{$post['body']}</p>
</div>
<h3>Komentáře:</h3>
<div id="comments">
{foreach $comments as $comment}
<div class="commment">
    <p>{$comment['body']}</p>
    <small>{$comment['author']}, {$comment['date']|date}</small>
<hr>
</div>
{/foreach}
</div>
{widget commentForm}
\--
Všimněte si, že formulář si sám najde cestu do šablony a vykreslí se. Zkuste odeslat formulář nevyplněný. Jak vidíte, Nette vygenerovalo validační Javascript k našemu formuláři. Ale validace funguje i s vypnutým Javascriptem.
Můžete se také místo makra `widget` setkat s jeho starším aliasem `control`. .[note]

Doufám, že jste se něco přiučili. Pokud už se v Nette trochu vyznáte a chcete další náměty, zkuste:
- Vypsat počet příspěvků/komentářů na hlavní stránku
- Přidat pár statických stránek a odkazy na ně
- Vytvořit jednoduchou administrace
- Zprovoznit stránkování příspěvků pomocí [VisualPaginator | addons:visualpaginator]
- K administraci přidejte [uživatelské účty | doc:autentizace]
- Přidat různé typy účtů, kontrolu oprávnění pomocí [ACL | doc:dynamicka-sprava-roli-a-zdroju]
- Upravit routování, generovat „cool URL“
Sám se těmto úlohám budu věnovat v budoucích tutoriálech (tedy doufám, moje lenost je nevyzpytatelná mrcha).

{{tags: tutorial}}

{{author: PJK|3073}}

Jednoduchý Model s NotORM
*************************

.[perex]
"NotORM":http://www.notorm.com/, knižnica na jednoduchú prácu s relačnými databázovými údajmi, je u mnohých Nette vývojárov preferovanou voľbou. Na rozdiel od "Nette\Database":http://doc10.nette.org/cs/database je vývoj NotORM vedený samostatne, autor môže flexibilnejšie reagovať na požiadavky developerov. Takisto podporuje pokročilé nastavenie menných konvencií, ktoré umožňuje používať názvy tabuliek vo forme "plurálu":http://cs.wikipedia.org/wiki/Mno%C5%BEn%C3%A9_%C4%8D%C3%ADslo.

Tento krátky tutoriál si kladie za cieľ naznačiť riešenie Modelovej vrstvy v Nette aplikáciách so zameraním na tieto požiadavky:

[* schema.png >]

- *pluralizovanie* názvov tabuliek
- vylúčenie (alebo minimalizovanie) akýchkoľvek statických volaní pri práci s Modelom
- veľmi tenká Modelová vrstva s jednoduchou možnosťou rozširovania
- zachovanie *lazy* pripojenia k databáze (vylúčenie volania pripojenia v `bootstrap.php`)

ModelLoader
===========

Hneď na začiatok uveďme príklad práce s Modelom, ktoré nevnáša povinnosť statického volania, ani nenúti explicitne inštancovať triedu s Modelom.

/--code php
final class FooPresenter extends BasePresenter
{
    public function renderDefault()
    {
        $this->template->applications = $this->getModel('applications')->findByName('Nette');
    }
}
\---

Prvé takéto volanie iniciuje pripojenie k databáze. Nejedná sa o skutočne lazy pripojenie iniciované prvým DB požiadavkom, ale takáto funkcionalita zväčša postačuje. Aby takéto volanie bolo dostupné vo všetkých Presenteroch, treba logicky umiestniť do `BasePresenter` definíciu metódy **`getModel()`**.

/--php
abstract class BasePresenter extends Nette\Application\Presenter
{
    protected function getModel($model)
    {
        return $this->getApplication()->getService('ModelLoader')->getModel($model);
    }
}
\--

Zavolanie `getModel()` v konkrétnom Presenteri v skutočnosti znamená získanie tzv. služby, ktorá nám obstaráva *naťahovanie* Modelov. Vďaka logike Nette služieb a konfigurácii v **`app/config.neon`** je v tomto konkrétnom prípade, pri prvom požiadavku na získanie **`ModelLoader`** inštancovaná a vrátená jeho trieda. Pri každom ďalšom požiadavku na `ModelLoader` je už používaná (vracaná) takto vytvorená inštancia.

To, ktorá trieda sa má inštancovať pri zavolaní `$application()->getService('ModelLoader')` je nastavené, ako sme už spomenuli v hlavnom konfiguračnom súbore **`app/config.neon`**.

/--
common:
    service:
        Nette\Loaders\RobotLoader:
            option:
                directory: [%appDir%, %libsDir%]
            run: true

        ModelLoader: Proj\ModelLoader

development < common:
    database:
        driver:   mysql
        host:     localhost
        database: notorm_demo
        username: php
        password: php
        profiler: true
\--

.[note]
Viac informácií o službách a ich konfigurácii nájdete "tu":http://forum.nette.org/cs/6506-jak-zaregistrovat-sluzbu-v-config-ini.

V tomto momente už teda Nette vie, ktorú triedu má inštancovať. Táto trieda bude samozrejme obsahovať metódu **`getModel()`**, ktorá bude vracať inštancie konkrétnych Modelov. Triedu **`Proj\ModelLoader`** doporučujeme umiestniť do **`libs\Proj\ModelLoader.php`**.

/--php
<?php

namespace Proj;

use Nette\Debug,
    Nette\Environment,
    PDO,
    NotORM,
    NotOrmPanel,
    NotORM_Structure_Convention;

class ModelLoader extends \Nette\Object
{
    private $dbConnection = null;
    private $models = array();

    public function getModel($model)
    {
        if (!isset($this->models[$model])) {
            $class = 'Model\\' . ucfirst($model);
            $this->models[$model] = new $class($this->dbConnection);
        }

        return $this->models[$model];
    }
}
\--

Najskôr si popíšme hore uvedenú metódu. Po jej zavolaní hľadáme vo veľmi jednoduchom *zásobníku* (reprezentovaným obyčajným poľom) inštanciu žiadaného Modelu. Ak sa Model nenájde, inštanciu vytvoríme, uložíme ju do zásobníku a z neho ju potom vrátime. Ide tu teda o jednoduché (dalo by sa povedať) kešovanie, pri mnohých požiadavkách na ten istý Model (počas jedného requestu samozrejme) sa nová inštancia nevytvára stále dookola. Všimnite si, že sme zaviedli konvenciu, že všetky Modely *sídlia* v namespace **Model**. Za zmienku ešte stojí, že do konštruktora Modelu predávame databázové pripojenie.

Vytvorenie databázového spojenia obstaráva koštruktor **`ModelLoader`**. Zároveň `ModelLoader` obsahuje užitočnú metódu na vrátenie samotného DB spojenia.

/--php
    public function __construct()
    {
        $this->dbConnect();
    }

    public function getConnection()
    {
        return (null === $this->dbConnection) ? $this->dbConnect() : $this->dbConnection;
    }

    private function dbConnect()
    {
        $cfg = Environment::getConfig('database');

        $pdo = new PDO("{$cfg->driver}:host={$cfg->host};dbname={$cfg->database}", $cfg->username, $cfg->password);
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        $pdo->query('SET NAMES utf8');

        $conn = new NotORM($pdo, new NotORM_Structure_Convention('id', '%s_id', '%ss'));

        if ($cfg->profiler) {
            $panel = NotOrmPanel::getInstance();
            $panel->setPlatform($cfg->driver);
            Debug::addPanel($panel);

            $conn->debug = function($query, $parameters) {
                NotOrmPanel::getInstance()->logQuery($query, $parameters);
            };
        }

        return $this->dbConnection = $conn;
    }
\--

V metóde **`dbConnect()`** sa nachádza jediné statické volanie (a okrem toho aj volanie singletonu, ktorý zabezpečuje profilovanie). Pri vytváraní objektu NotORM nastavujeme vlastnú konvenciu, ktorá zabezpečí podporu pluralizovaných názvov DB tabuliek. Jednotlivé parametre konštruktora **`NotORM_Structure_Convention`** znamenajú:

- konvencia pre nazývanie PK
- konvencia pre nazývanie FK
- konvencia pre nazývanie tabuliek

Modifikátor **`%s`** zastupuje názov samotnej tabuľky.

.[note]
Profiler pre NotORM je možné nájsť na "tomto":http://forum.nette.org/cs/5943-notorm-panel-profiler-panel-pre-nette-debug mieste.

Modely
======
 V úvode uvedený Model by zjavne mal obsahovať definíciu metódy **`findByName`**. Jeho kód však prezrádza niečo iné.

/--php
<?php

namespace Model;

class Applications extends Base
{

}
\--

Metódy typu **`findBy*`** sa veľmi často opakujú, mení sa len *stĺpec*, podľa ktorého chceme vyhľadávať. Zapojme preto trocha "mágie":http://php.net/manual/en/language.oop5.magic.php.

/--php
<?php

namespace Model;

class Base extends \Nette\Object
{
    protected $connection = null;
    protected $tableName = '';

    public function __construct($dbConnection)
    {
        $this->connection = $dbConnection;
        $classNameParts = explode('\\', get_class($this));
        $this->tableName = strtolower(array_pop($classNameParts));
    }

    public function getAll()
    {
        return $this->connection->{$this->tableName}();
    }

    public function __call($name, $args)
    {
        if (false !== strpos($name, 'findBy')) {
            $cammelCaseSplit = preg_split('~(?<=\\w)(?=[A-Z])~', str_replace('findBy', '', $name));
            $loweredCammels = array_map(function($in) {
                return strtolower($in);
            }, $cammelCaseSplit);
            $findCondition = implode('.', $loweredCammels);

            if (isset($args[1]) && true === $args[1]) {
                // M:N relation
                $relationTableName = $loweredCammels[0] . 's_' . $this->tableName;
                $mn = $this->connection->{$relationTableName}($findCondition, $args[0])
                    ->select(substr($this->tableName, 0, -1) . '_id');

                try {
                    $result = $this->connection->{$this->tableName}('id', $mn);

                } catch (\PDOException $e) {
                    if (false !== strpos($e->getMessage(), 'Table') && false !== strpos($e->getMessage(), 'doesn\'t exist')) {
                        // switch table name elements
                        $relationTableName = $this->tableName . '_' . $loweredCammels[0] . 's';
                        $mn = $this->connection->{$relationTableName}($findCondition, $args[0])
                            ->select(substr($this->tableName, 0, -1) . '_id');

                        $result = $this->connection->{$this->tableName}('id', $mn);

                    } else {
                        throw $e;
                    }
                }

                return $result;

            } else {
                // no or 1:N relation
                return $this->connection->{$this->tableName}()
                    ->where($findCondition, $args[0]);
            }
        }
    }
}
\--

Toto už vypadá trocha krypticky, poďme sa na kód metódy **`__call()`** pozrieť bližšie. Po zavolaní **`$model->findByName('Nette')`** metóda obdrží v parametroch tieto údaje

/--
findByName

Array
(
    [0] => Nette
)
\--

V prvom kroku hľadáme v názve volanej metódy reťazec **findBy**. Ak sa nájde, rozsekáme si názov metódy podľa veľkých písmen pomocou regulárneho reťazca (predtým ešte odstránime už nepotrebný reťazec **findBy**).

.[note]
Prečo je názov rozsekaný na jednotlivé slová aj pri odstránenom **findBy** si vysvetlíme o chvíľu. Magická metóda **`__call()`** umožňuje vyhľadávať aj podľa stĺpcov v pridružených tabuľkách.

/--
Array
(
    [0] => Name
)
\--

Každé získane slovo je následne prehnané cez funkciu **`strtolower()`**. Slová sú potom *zlepené* znakom **.** (bodka). Pri jednoduchom volaní **`findByName('Nette')`** dostaneme (v premennej **`$findCondition`**) obyčajný string '`name`'.

V nasledujúcom kroku overujeme počet argumentov ktoré sme do **`findByName()`** predali. V našom príklade prvok **`$args[1]`** nebude nastavený a pokračuje sa vetvou `else`. Dynamicky dôjde k zostaveniu kódu, ktorého výsledok vrátime do zdroja volania

/--php
$this->connection->applications()->where('name', 'Nette');
\--

relácie 1:N
-----------

Ako sme už spomenuli v poznamke vyššie, táto Modelová vrstva umožňuje *WHERE* aj podľa stĺpca v pridruženej tabuľke

/--php
$this->template->applications = $this->getModel('applications')->findByAuthorName('David Grudl');
\--

Výsledkom bude, že vo **`$findCondition`** sa objaví 'author.name', čo NotORM (aj vďaka nastavenej mennej konvencii) donúti hľadať všetky záznamy v tabuľke **aplications**, ktoré majú reláciu do tabuľky **authors** a stĺpec **name** obsahuje žiadanú hodnotu.

relácie M:N
-----------

Magická metóda **`__call()`** nakoniec umožňuje špecifikovať podmienku WHERE aj v tabuľkách spojených reláciou M:N.

/--php
$this->template->applications = $this->getModel('applications')->findByTagName('dabases', $mnRelation = true);
\--

Do metódy si však vtedy posielame ďalší parameter, pretože takéto vyhľadávanie vyžaduje dva SELECTy a metóda musí tento prípad *rozvetviť* (viď vyššie **`$args[1]`**). Väzobná tabuľka môže byť pomenovaná dvojako:

- `applications_tags`
- `tags_applications`

V metóde pomocou konštrukcie *try/chatch* zachytávame prípadný hazard, ak metóda najskôr skúša reláciu podľa nesprávnej možnosti.

Download
========

Kompletnú Nette aplikaciu s SQL skriptami si stiahnite z "archívu":http://files.nette.org/1474/notorm-model-v2.zip (neobsahuje knižnice Nette a NotORM, obsahuje NotORM panel profiler).

Known issues
============

Pluralizovanie tabuliek funguje iba pri konvenčnom anglickom tvorení množného čísla. Bohužial momentálne neexistuje riešenie pre tieto príklady

- Category => Categories
- Octopus => Octopi
- Matrix => Matrixes

Jedinou možnosťou bude nastavenie nejakého prekladového slovníka v mennej konvencii.

{{tags: cookbook}}

{{author: srigi|1860}}

Inject a DIC továrničky
******************

.[perex]
Jak jistě všichni víme, [Dependency Injection Container | doc:configuring] se stará o služby, které používáme v aplikaci. Jenže občas nám může vadit, že nám vrací vždy stejnou instanci.

Nejčastějším příkladem jsou komponenty.


Proč vlastně vytvářet komponenty přes DIC?
======

V momentě, kdy by komponenta byla složitější a potřebovala nějakou jinou službu, například databázi, tak bychom měli dvě možnosti. Buďto budeme komponentu vytvářet ručně a `Connection` si předáme do presenteru

/--php
class ArticlePresenter extends BasePresenter
{
	/** @var Nette\Database\Connection */
	private $db;

	public function injectDb(Nette\Database\Connection $db)
	{
		$this->db = $db;
	}

	protected function createComponentArticles()
	{
		return new ArticlesControl($this->db);
	}

}
\--

Což je přijatelné, ale jen dokud bude mít komponenta jednu dvě závislosti. No a nebo si komponentu necháme vytvářet pomocí v DIC


Jak to **ne**dělat
======

Nakonfigurujeme

/--neon
services:
	- ArticlesControl(@db)
\--

a nyní si komponentu můžeme injectnout

/--php
class ArticlePresenter extends BasePresenter
{
	public function injectSlozita(ArticlesControl $articles)
	{
		$this->addComponent($articles, 'articles');
	}
}
\--

Proč je to špatně? Protože po celý běh aplikace budeme mít k dispozici pouze jednu jedinou instanci této třídy. Komponenty jsou vzorem znovupoužitelnosti a když ji nebudu moct mít v jednom presenteru připojenou dvakrát, jen pod jiným jménem, tak se připravujeme o mocnou zbraň.

Navíc je instance komponenty vytvořena okamžitě, při vytvoření instance presenteru. To také není žádoucí.


Trošku lépe
======

Nette Framework nám dovoluje nakonfigurovat tzv. "factories"((továrničky)). Stačí přesunout definici služby ze `services` do `factories` a máme to

/--neon
factories:
	articles:
		create: ArticlesControl(@db)
\--

.[note]
Více o "starých" továrnách [zde v dokumentaci |doc:configuring#toc-tovarny].

S touhle konfigurací se nám do DIC vygeneruje takováto tovární metoda,

/--php
	public function createArticles()
	{
		$service = new ArticlesControl($this->getService('nette.database.default'));
		$this->callInjects($service);
		return $service;
	}
\--

kterou můžeme takto volat nad DI Containerem

/--php
class ArticlePresenter extends BasePresenter
{

	protected function createComponentArticles()
	{
		return $this->context->createArticles();
	}

}
\--

Přináší to ovšem problémy. Jde o to, že bez `$this->context` v presenteru metodu prostě nezavoláme.

To by byl ale ten menší problém, protože `$this->context` (DI Container) je v presenteru automaticky (byť možné né nadlouho). Co když budeme takovou tovární metodu využívat v jiné službě? Nebo budeme chtít takto vytvářet komponentu v komponentě v komponentě? Nesmějte se, to je velice reálný požadavek.

Všude, kde bychom chtěli vytvářet instanci `ArticlesControl` bychom si museli předat DI Container - tudy cesta nevede. [Nebudeme si předávat piáno, když chceme pouze doutník |pla:posobota-38-david-grudl-dependency-injection].


Jak je to správně
======

Napíšeme si interface pro továrničku, kterou budeme vyžadovat v presenteru

/--php
interface IArticlesControlFactory
{
	/** @return ArticlesControl */
	function create();
}
\--

a nakonfigurujeme

/--neon
factories:
	articles:
		create: ArticlesControl
		implement: IArticlesControlFactory
\--

.[note]
Vlastnost `create` se "ještě nedávno":https://github.com/nette/nette/commit/23c3f6ca0df8ffc6da9aad1fb02f0cdb4f9505b0 jmenovala `factory`. Zatím platí pouze pro vývojovou verzi.

Kdybych nenapsal do `create`, že `ArticlesControlFactory` bude vytvářet `ArticlesControl`, tak se Nette Framework koukne na `IArticlesControlFactory::create()`, jestli nemá annotaci `@return` a kdyby ano, tak si z ní sám zjistí, jakou třídu bude vytvářet.

.[note]
Pokud mu neřekneme co má vytvářet a není ani přítomná annotace @return, Nette nás na to důrazně upozorní výjimkou.

Až Nette tohle všechno zkontroluje, tak samo vygeneruje třídu, která bude tento interface implementovat. Vygenerovaná třída může vypadat takto

/--php
final class ArticlesControlFactoryImpl_articlesControl implements IArticlesControlFactory
{
	private $container;

	public function __construct(Nette\DI\Container $container)
	{
		$this->container = $container;
	}

	public function create()
	{
		$service = new ArticlesControl($this->container->getService('nette.database.default'));
		$this->container->callInjects($service);
		return $service;
	}
}
\--

Tato třída bude registrována jako služba a můžeme si ji injectnout do presenteru a použít

/--php
class ArticlesPresenter extends BasePresenter
{

	/**
	 * @var IArticlesControlFactory
	 */
	private $articlesFactory;

	/**
	 * @param IArticlesControlFactory $articlesFactory
	 */
	public function injectArticlesFactory(IArticlesControlFactory $articlesFactory)
	{
		$this->articlesFactory = $articlesFactory;
	}

	/**
	 * @return ArticlesControl
	 */
	protected function createComponentArticles()
	{
		return $this->articlesFactory->create();
	}

}
\--

.[warning]
Naše aplikace se musí spoléhat pouze na interface, který jsme sami napsali! Nikdy se nesnažte vyžadovat factory, podle názvu třídy, může se kdykoliv změnit! Implementaci řeší Nette, nás zajímá jenom a pouze interface.

Pojďme si to shrnout:
1) vytvoříme třídu (komponentu, formulář, ...), kterou potřebujeme
2) vytvoříme interface pro factory, která ji bude vytvářet, a kterou bude generovat DIC
3) toto všechno nakonfigurujeme
4) do presenteru přidáme `inject*()` metodu, která bude přijímat vygenerovanou factory
5) napíšeme si továrničku, která bude používat vygenerovanou factory, volat `->create()` a registrovat komponentu do presenteru

Může to vypadat maličko ukecané, ale je to velice mocné.


A co formuláře?
=====

Než jsme měli k dispozici generované továrničky, David "doporučoval psát je ručně":http://forum.nette.org/cs/11883-vicenasobne-pouziti-formulare-dedicnost-nebo-tovarna. A když už jsme je psali ručně, tak jsme do nich mohli rovnou psát třeba i jejich obsluhu.

To je samozřejmě **stále naprosto validní** přístup. Jenže někomu by se nemuselo líbit, že se factory stará o zpracování formuláře. Třeba mně ;)

.[tip]
Nerad bych zde rozebíral metodiku vytváření formulářů, [od toho je tu jiný článek |pla:dedicnost-vs-kompozice]. Použijeme tedy nejkratší možný způsob.

Místo vytváření formuláře v továrničce si podědíme `UI\Form` a nakonfigurujeme v konstruktoru

/--php
class CreateOrEditUserForm extends Nette\Application\UI\Form
{
	private $db;

	public function __construct(Nette\Database\Connection $db, $userId)
	{
		parent::__construct(); // vždy volat parent !!
		$this->db = $db;

		$this->addHidden('userId', $userId);
		$this->addSubmit('send', 'Update Account');
		$this->addSubmit('sendandview', 'Update Account and continue editing')
			->onClick[] = $this->process;
	}

	public function process($button)
	{
		// ...
	}
}
\--

Dopíšeme si interface pro továčničku,

/--php
interface ICreateOrEditUserFormFactory
{
	/** @return CreateOrEditUserForm */
	function create($userId);
}
\--

nakonfigurujeme

/--neon
factories:
	userForm:
		create: App\CreateOrEditUserForm(..., %userId%)
		implement: App\ICreateOrEditUserFormFactory
		parameters: [userId]
\--

a používáme.

/--php
class UserPresenter extends BasePresenter
{

	/**
	 * @persistent
	 */
	public $userId = 0;

	/**
	 * @var ICreateOrEditUserFormFactory
	 */
	private $userFormFactory;

	/**
	 * @param ICreateOrEditUserFormFactory $userFormFactory
	 */
	public function injectUserFormFactory(ICreateOrEditUserFormFactory $userFormFactory)
	{
		$this->userFormFactory = $userFormFactory;
	}

	/**
	 * @return CreateOrEditUserForm
	 */
	protected function createComponentUserForm()
	{
		return $this->userFormFactory->create($this->userId);
	}
}
\--

{{author: Filip Procházka|2118}}
